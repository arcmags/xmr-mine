#!/bin/bash
##==============================  xmr-mine  ==============================##
# Copyright (C) 2017 arcmags                 GNU General Public License v3 #
##========================================================================##
# Basic wrapper script for xmr-stak.

print_help() {
cat <<'EODOC'
NAME
    xmr-mine

SYNOPSIS
    xmr-mine [ARGUMENTS]

DESCRIPTION
    Wrapper script for xmr-stak.  Check for internet connection and
    system clock sync.  Check processor for AES support.
    Check if xmr-stak is already running.  Launch xmr-stak with config
    file built by script or specified by arguments.  Current miner stats
    can be viewed via --hash or --status arguments.

REQUIREMENTS
    xmr-stak
        Monero unified CPU/GPU pool miner.

    timedatectl set-ntp true
        This script ensures system clock is synced via the systemd-
        timesyncd.service before launching xmr-stak.

OPTIONS
    -B, --background
        Set verbose_level=0, launch in daemon mode, and
        fork to background.

    -C, --config
        Use XMR_CONFIG file as config.txt.

    --cpu
        Use XMR_CPU file as cpu.txt.

    -D, --dryrun
        Run script and generate config.txt without launching xmr-stak

    -G, --gen-config, --generate-config
        Use xmr-stak to generate a new config in the DIR_MINE directory.
        Newly generated config files must be copied manually to XMR_CONFIG
        if future use is desired.

    -H, --hash
        Print hash rate.

    --help
        Print help.

    -I, --incognito
        Launch xmr-stak in daemon mode piping all output to /dev/null.

    -K, --kill
        Kill any instances of xmr-stak.

    -N, --nvidia
        Use XMR_NVIDIA file as nvidia.txt.

    -R, --random-pool, --random-weight
        Randomize pool weights.

    -S, --status
        Print current pool status and hash rate.

    -W, --wallet
        Print XMR wallet address.

CONFIGURATION
    Every xmr-stak config.txt variable is set in the XMR-STAK SETTINGS
    section of this script.  These are used to build config.txt upon every
    run unless a config file is specified.  (Right now cpu.txt and
    nvidia.txt can be either specified or generated by xmr-stak.)

    A valid machine lookup name must be specified by MINER_NAME in order
    to correctly display miner stats.

SEE ALSO:
    https://github.com/arcmags/xmr-mine
    https://github.com/fireice-uk/xmr-stak
EODOC
}


##=======================  XMR-STAK SETTINGS  ========================##
# wallet:
wallet_address="$XMR_WALLET"
# pools:
pool_addresses=(
    'pool.supportxmr.com:3333'
    'monerohash.com:3333'
    'pool.monero.hashvault.pro:5555'
)
pool_passwords=(
    "$HOSTNAME"
    "$HOSTNAME"
    "$HOSTNAME"
)
pool_weights=(
    3
    2
    1
)
use_nicehash='false'
use_tls='false'
tls_fingerprint=''
# globals:
currency='monero'
call_timeout=10
retry_time=30
giveup_limit=0
verbose_level=4
print_motd='false'
h_print_time=60
aes_override='null'
use_slow_memory='warn'
tls_secure_algo='true'
daemon_mode='false'
flush_stdout='false'
output_file=''
httpd_port=16000
http_login=''
http_pass=''
prefer_ipv4='true'


##===========================  VARIABLES  ============================##
# default xmr-stak config files:
XMR_CONFIG="$HOME/.xmr-mine/config.txt"
XMR_CPU="$HOME/.xmr-mine/cpu.txt"
XMR_NVIDIA="$HOME/.xmr-mine/nvidia.txt"
# machine name (for printing stats):
MINER_NAME="$HOSTNAME.localdomain"
# script variables:
DIR_MINE='/tmp/xmr-mine'
# script flags:
FLAG_CONFIG_FILE='false'
FLAG_CPU_FILE='false'
FLAG_DAEMON='false'
FLAG_DRYRUN='false'
FLAG_ERROR='false'
FLAG_HASH='false'
FLAG_HELP='false'
FLAG_INCOGNITO='false'
FLAG_CONFIG_NEW='false'
FLAG_KILL='false'
FLAG_NVIDIA_FILE='false'
FLAG_RANDOM_WEIGHTS='false'
FLAG_STATUS='false'
FLAG_WALLET='false'


##===========================  FUNCTIONS  ============================##
# Check internet connection.
net_check() {
    if (ping -q -c 1 -W 3 google.com &> /dev/null) ||
    (ping -q -c 1 -W 5 archlinux.org &> /dev/null); then
        return 0
    else
        return 1
    fi
}

# Check system clock sync status.
ntp_check() {
    return `timedatectl | \
        grep 'timesyncd.service active: yes' >/dev/null`
}

# Check miner state.
mine_check() {
    # FAIL: no AES support:
    if !(cat /proc/cpuinfo | grep -P 'flags\s*:.* aes( |$)' >/dev/null); then
        printf ":! CPU does not support AES\n"
        printf ":: unable to launch xmr-stak\n"
        exit 3
    fi
    # FAIL: xmr-stak already running:
    if (pgrep -x xmr-stak >/dev/null); then
        printf ":! xmr-stak is already running\n"
        exit 2
    fi
    # FAIL: no internet connection:
    if !(net_check); then
        printf ":! no internet connection\n"
        exit 1
    fi
    # FAIL: system clock not synced:
    if !(ntp_check); then
        printf ":! system clock not synced\n"
        exit 1
    fi
    return 0
}

# Kill miner (xmr-stak).
mine_kill() {
    if (pgrep -x xmr-stak >/dev/null); then
        pkill xmr-stak
        printf ":: killed xmr-stak\n"
    else
        printf ":: not mining\n"
    fi
    return 0
}

# Print current pool status and hash rate.
print_mine_status() {
    if (pgrep -x xmr-stak >/dev/null); then
        XMR_JSON="`curl -s ${MINER_NAME}:${httpd_port}/api.json`"
        HASH_RATE="`printf "$XMR_JSON" | \
            grep -Po '"total": ?\[\K[^,]+(?=,)'`"
        if [ "$HASH_RATE" = 'null' ]; then
            HASH_RATE='no data yet'
        fi
        POOL_ADDRESS="`printf "$XMR_JSON" | \
            grep -Po '"pool": ?"\K[^:]+(?=(:|"))'`"
        UP_SECS="`printf "$XMR_JSON" | \
            grep -Po '"uptime": ?\K[0-9]+(?=,)'`"
        UP_DAYS=$(( $UP_SECS / 86400 ))
        UP_SECS=$(( $UP_SECS % 86400 ))
        UP_HOURS=$(( $UP_SECS / 3600 ))
        UP_SECS=$(( $UP_SECS % 3600 ))
        UP_MINS=$(( $UP_SECS / 60 ))
        UP_SECS=$(( $UP_SECS % 60 ))
        UP_TEXT=''
        if [ $UP_DAYS -gt 0 ]; then
            UP_TEXT="${UP_DAYS}d "
        fi
        UP_TEXT+="`printf "%02d:%02d:%02d" \
            $UP_HOURS $UP_MINS $UP_SECS`"
        POOL_PING="`printf "$XMR_JSON" | \
            grep -Po '"ping": ?\K[0-9]+(?=,)'`"
        # print hash rate only:
        if [ "$FLAG_HASH" = 'true' ]; then
            printf ":: hash rate: $hashRate\n"
        # print full status:
        else
            printf ":: pool address: $POOL_ADDRESS\n"
            printf "           ping: $POOL_PING\n"
            printf "         uptime: $UP_TEXT\n"
            printf "      hash rate: $HASH_RATE\n"
        fi
    else
        printf ":: not mining\n"
    fi
    return 0
}

# Print wallet address.
print_wallet() {
    printf ":: wallet: "
    if [ `tput cols` -lt 107 ]; then
        printf "${wallet_address:0:48}\n"
        printf "           ${wallet_address:48}\n"
    else
        printf "${wallet_address}\n"
    fi
    if !(pgrep -x xmr-stak >/dev/null); then
        printf ":: not mining\n"
    fi
    return 0
}

# Copy existing config file or let script build one.
config_file() {
    if [ "$FLAG_CONFIG_FILE" = 'true' ]; then
        # use existing config:
        if [ -f "$XMR_CONFIG" ]; then
            cp "$XMR_CONFIG" ./config.txt
        # build new config:
        else
            printf ":! no config file found\n"
            printf ":: generating new config.txt\n"
            config_build
        fi
    # build new config:
    else
        config_build
    fi
    return 0
}

# Copy existing cpu config file or let xmr-stak build one.
cpu_file() {
    if [ -f "$XMR_CPU" ]; then
        cp "$XMR_CPU" ./cpu.txt
    else
        printf ":! no cpu file found\n"
        printf ":: generating new cpu.txt\n"
    fi
    return 0
}

# Copy existing nvidia config file or let xmr-stak build one.
nvidia_file() {
    if [ -f "$XMR_NVIDIA" ]; then
        cp "$XMR_NVIDIA" ./nvidia.txt
    else
        printf ":! no nvidia file found\n"
        printf ":: generating new nvidia.txt\n"
    fi
    return 0
}

# Build xmr-stak config.txt file.
config_build() {
    local XMR_CONFIG_TEXT=''
    # generate random pool weights:
    if [ "$FLAG_RANDOM_WEIGHTS" = 'true' ]; then
        pool_weights=( `shuf -i 1-${#pool_addresses[@]} \
            -n ${#pool_addresses[@]}` )
    fi
    # add pool list:
    XMR_CONFIG_TEXT="\"pool_list\" :\n"
    XMR_CONFIG_TEXT+="[\n"
    i=0
    for POOL in ${pool_addresses[@]}; do
        XMR_CONFIG_TEXT+="  {\n"
        XMR_CONFIG_TEXT+="    \"pool_address\" : \"$POOL\",\n"
        XMR_CONFIG_TEXT+="    \"wallet_address\" : \"$wallet_address\",\n"
        XMR_CONFIG_TEXT+="    \"pool_password\" : \"${pool_passwords[i]}\",\n"
        XMR_CONFIG_TEXT+="    \"pool_weight\" : ${pool_weights[i]},\n"
        XMR_CONFIG_TEXT+="    \"use_nicehash\" : $use_nicehash,\n"
        XMR_CONFIG_TEXT+="    \"use_tls\" : $use_tls,\n"
        XMR_CONFIG_TEXT+="    \"tls_fingerprint\" : \"$tls_fingerprint\"\n"
        XMR_CONFIG_TEXT+="  },\n"
        ((i++))
    done
    XMR_CONFIG_TEXT+="],\n"
    # add global settings:
    XMR_CONFIG_TEXT+="\"currency\" : \"$currency\",\n"
    XMR_CONFIG_TEXT+="\"call_timeout\" : $call_timeout,\n"
    XMR_CONFIG_TEXT+="\"retry_time\" : $retry_time,\n"
    XMR_CONFIG_TEXT+="\"giveup_limit\" : $giveup_limit,\n"
    XMR_CONFIG_TEXT+="\"verbose_level\" : $verbose_level,\n"
    XMR_CONFIG_TEXT+="\"print_motd\" : $print_motd,\n"
    XMR_CONFIG_TEXT+="\"h_print_time\" : $h_print_time,\n"
    XMR_CONFIG_TEXT+="\"aes_override\" : $aes_override,\n"
    XMR_CONFIG_TEXT+="\"use_slow_memory\" : \"$use_slow_memory\",\n"
    XMR_CONFIG_TEXT+="\"tls_secure_algo\" : $tls_secure_algo,\n"
    XMR_CONFIG_TEXT+="\"daemon_mode\" : $daemon_mode,\n"
    XMR_CONFIG_TEXT+="\"flush_stdout\" : $flush_stdout,\n"
    XMR_CONFIG_TEXT+="\"output_file\" : \"$output_file\",\n"
    XMR_CONFIG_TEXT+="\"httpd_port\" : $httpd_port,\n"
    XMR_CONFIG_TEXT+="\"http_login\" : \"$http_login\",\n"
    XMR_CONFIG_TEXT+="\"http_pass\" : \"$http_pass\",\n"
    XMR_CONFIG_TEXT+="\"prefer_ipv4\" : $prefer_ipv4,\n"
    printf "$XMR_CONFIG_TEXT" > config.txt
    return 0
}


##=============================  SCRIPT  =============================##
# parse args:
for arg in "$@"; do case $arg in
    -B|--background)  shift;  FLAG_DAEMON='true'                     ;;
    -C|--config)      shift;  FLAG_CONFIG_FILE='true'             ;;
    --cpu)            shift;  FLAG_CPU_FILE='true'             ;;
    -D|--dryrun)      shift;  FLAG_DRYRUN='true'                 ;;
    -G|--gen-config|--generate-config)  shift;  FLAG_CONFIG_NEW='true'  ;;
    -H|--hash)        shift;  FLAG_HASH='true'                       ;;
    --help)           shift;  FLAG_HELP='true'                       ;;
    -I|--incognito)   shift;  FLAG_INCOGNITO='true'; FLAG_DAEMON='true'  ;;
    -K|--kill)        shift;  FLAG_KILL='true'                       ;;
    -N|--nvidia)      shift;  FLAG_NVIDIA_FILE='true'  ;;
    -R|--random-pool)  shift;  FLAG_RANDOM_WEIGHTS='true'    ;;
    -S|--status)      shift;  FLAG_STATUS='true'                     ;;
    -W|--wallet)      shift;  FLAG_WALLET='true'                     ;;
esac; done

# print help:
if [ "$FLAG_HELP" = 'true' ]; then
    print_help
    exit 0
fi

# kill any xmr-stak instance:
if [ "$FLAG_KILL" = 'true' ]; then
    mine_kill
    exit 0
fi

# print pool status and hash rate:
if [ "$FLAG_HASH" = 'true' ] || [ "$FLAG_STATUS" = 'true' ]; then
    print_mine_status
    exit 0
fi

# print wallet address:
if [ "$FLAG_WALLET" = 'true' ]; then
    print_wallet
    exit 0
fi

# check miner state:
mine_check

# switch to mining directory:
mkdir -p "$DIR_MINE"
cd "$DIR_MINE"

# use existing config or let script build new config.txt:
if [ "$FLAG_CONFIG_NEW" = 'false' ]; then
    config_file
else
    if [ -f config.txt ]; then
        rm config.txt
    fi
fi

# enable daemon_mode in config.txt:
if [ -f ./config.txt ] && [ "$FLAG_DAEMON" = 'true' ]; then
    sed -i 's/"daemon_mode" : false,/"daemon_mode" : true,/g;
        s/"verbose_level" : .*,/"verbose_level" : 0,/g;' config.txt
else
    FLAG_DAEMON='false'
fi

# copy default cpu config or let xmr-stak build new cpu.txt:
if [ "$FLAG_CPU_FILE" = 'true' ]; then
    cpu_file
fi

# copy default nvidia config or let xmr-stak build new nvidia.txt:
if [ "$FLAG_NVIDIA_FILE" = 'true' ]; then
    nvidia_file
fi

# launch xmr-stak:
if [ "$FLAG_DRYRUN" = 'false' ]; then
    # daemon mode:
    if [ "$FLAG_DAEMON" = 'true' ]; then
        # daemon incognito mode:
        if [ "$FLAG_INCOGNITO" = 'true' ]; then
            xmr-stak >/dev/null 2>&1 &
            sleep 2
        # daemon normal mode:
        else
            xmr-stak &
            sleep 2
            printf ":: xmr-stak forked to background PID: $!\n"
        fi
    # normal mode:
    else
        exec /usr/bin/xmr-stak
    fi
fi

exit 0
