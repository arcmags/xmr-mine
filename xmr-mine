#!/bin/bash
##==============================  xmr-mine  ==============================##
# Copyright (C) 2017 arcmags                 GNU General Public License v3 #
##========================================================================##
# Basic wrapper script for xmr-stak.

print_help() {
cat <<'EODOC'
NAME
    xmr-mine

SYNOPSIS
    xmr-mine [ARGUMENTS]

DESCRIPTION
    Wrapper script for xmr-stak.  Check for internet connection and
    system clock sync.  Check processor for AES support.
    Check if xmr-stak is already running.  Launch xmr-stak with config
    file built by script or specified by arguments.  Current miner stats
    can be viewed via --hash or --status arguments.

REQUIREMENTS
    xmr-stak
        Monero unified CPU/GPU pool miner.

    timedatectl set-ntp true
        This script ensures system clock is synced via the systemd-
        timesyncd.service before launching xmr-stak.

OPTIONS
    --background, -B
        Set verbose_level=0, launch in daemon mode, and
        fork to background.

    --config, -C
        Use XMR_CONFIG file as config.txt.

    --cpu
        Use XMR_CPU file as cpu.txt.

    --dryrun, D
        Run script and generate config.txt without launching xmr-stak

    --gen-config, -G
        Use xmr-stak to generate a new config in the DIR_MINE directory.
        Newly generated config files must be copied manually to XMR_CONFIG
        if future use is desired.

    --help
        Print help.

    --kill, -K
        Kill any instances of xmr-stak.

    --nvidia, -N
        Use XMR_NVIDIA file as nvidia.txt.

    --pool, -p <ADDRESS:PORT>
        Specify default pool address and port number.  Pool is added
        to the list of pools and given the highest weight.

    --password, --pass <POOL PASSWORD>
        Password used to login to default pool.  HOSTNAME is used if no
        password is specified.

    --quiet, -Q
        Launch xmr-stak in daemon mode.  Pipe all output to /dev/null.

    --random-pool, -R
        Randomize pool weights.

    --show-hash, -H
        Print hash rate.

    --show-status, -S
        Print current pool status and hash rate.

    --show-wallet, -W
        Print XMR wallet address.

    --wallet, -w <XMR ADDRESS>
        Specify xmr wallet to mine to.

ENVIRONMENT VARIABLES
    The default behavior of xmr-mine can may be affected by
    setting optional environment variables.

    XMR_WALLET
        Default wallet address.

    XMR_POOL
        Default xmr mining pool address and port number.  This is added
        to the list of pools addresses and given the highest weight.

    XMR_POOL_PASSWORD
        Pool password used for default pool.  HOSTNAME is used if no
        password is set.  Some pools arc capable a monitoring
        individual miners identified by the pool password.

    XMR_CONFIG_DIRECTORY
        Directory containing any xmr-stak configuration files.  ~/.xmr-mine
        is used if left unset.

CONFIGURATION FILES



CONFIGURATION
    Every xmr-stak config.txt variable is set in the XMR-STAK SETTINGS
    section of this script.  These are used to build config.txt upon every
    run unless a config file is specified.  (Right now cpu.txt and
    nvidia.txt can be either specified or generated by xmr-stak.)

    A valid machine hostname and domain must be specified by
    MINER_NAME in order to correctly display miner stats.

SEE ALSO:
    https://github.com/arcmags/xmr-mine
    https://github.com/fireice-uk/xmr-stak
EODOC
}


##=======================  XMR-STAK SETTINGS  ========================##
# default wallet:
wallet_address="$XMR_WALLET"
# default pool:
pool_address="$XMR_POOL"
pool_password="${XMR_POOL_PASSWORD:-$HOSTNAME}"
# pools:
pool_addresses=(
    'pool.supportxmr.com:3333'
    'monerohash.com:3333'
    'pool.monero.hashvault.pro:5555'
)
pool_passwords=(
    "$HOSTNAME"
    "$HOSTNAME"
    "$HOSTNAME"
)
pool_weights=(
    3
    2
    1
)
use_nicehash='false'
use_tls='false'
tls_fingerprint=''
# globals:
currency='monero'
call_timeout=10
retry_time=30
giveup_limit=0
verbose_level=4
print_motd='false'
h_print_time=60
aes_override='null'
use_slow_memory='warn'
tls_secure_algo='true'
daemon_mode='false'
flush_stdout='false'
output_file=''
httpd_port=16000
http_login=''
http_pass=''
prefer_ipv4='true'


##===========================  VARIABLES  ============================##
# default xmr-stak config files:
DIR_CONFIG="$HOME/.xmr-mine"
XMR_CONFIG="$DIR_CONFIG/config.txt"
XMR_CPU="$DIR_CONFIG/cpu.txt"
XMR_NVIDIA="$DIR_CONFIG/nvidia.txt"
# machine name (for printing stats):
MINER_NAME="$HOSTNAME.localdomain"
# script variables:
DIR_MINE='/tmp/xmr-mine'
# script flags:
FLAG_CONFIG_FILE='false'
FLAG_CPU_FILE='false'
FLAG_DAEMON='false'
FLAG_DRYRUN='false'
FLAG_ERROR='false'
FLAG_HASH='false'
FLAG_HELP='false'
FLAG_INCOGNITO='false'
FLAG_CONFIG_NEW='false'
FLAG_KILL='false'
FLAG_NVIDIA_FILE='false'
FLAG_RANDOM_POOL='false'
FLAG_STATUS='false'
FLAG_WALLET='false'


##===========================  FUNCTIONS  ============================##
# Check internet connection.
net_check() {
    if (ping -q -c 1 -W 3 google.com &> /dev/null) ||
    (ping -q -c 1 -W 5 archlinux.org &> /dev/null); then
        return 0
    else
        return 1
    fi
}

# Check system clock sync status.
ntp_check() {
    return `timedatectl | \
        grep 'timesyncd.service active: yes' >/dev/null`
}

# Execute specified action from FLAG.
mine_action()
    # print help:
    if [ "$FLAG_HELP" = 'true' ]; then
        print_help
        exit 0
    # kill any xmr-stak instance:
    elif [ "$FLAG_KILL" = 'true' ]; then
        mine_kill
        exit 0
    # print pool status and hash rate:
    elif [ "$FLAG_HASH" = 'true' ] || [ "$FLAG_STATUS" = 'true' ]; then
        print_mine_status
        exit 0
    # print wallet address:
    elif [ "$FLAG_WALLET" = 'true' ]; then
        print_wallet
        exit 0
    fi
    return 0
}

# Precheck system before launching xmr-stak.
mine_precheck() {
    # FAIL: no AES support:
    if !(cat /proc/cpuinfo | grep -P 'flags\s*:.* aes( |$)' >/dev/null); then
        printf ":! CPU does not support AES\n"
        printf ":: unable to launch xmr-stak\n"
        exit 3
    fi
    # FAIL: xmr-stak already running:
    if (pgrep -x xmr-stak >/dev/null); then
        printf ":! xmr-stak is already running\n"
        exit 2
    fi
    # FAIL: no internet connection:
    if !(net_check); then
        printf ":! no internet connection\n"
        exit 1
    fi
    # FAIL: system clock not synced:
    if !(ntp_check); then
        printf ":! system clock not synced\n"
        exit 1
    fi
    return 0
}

# Kill miner (xmr-stak).
mine_kill() {
    if (pgrep -x xmr-stak >/dev/null); then
        pkill xmr-stak
        printf ":: killed xmr-stak\n"
    else
        printf ":: not mining\n"
    fi
    return 0
}

# Print current pool status and hash rate.
print_mine_status() {
    if (pgrep -x xmr-stak >/dev/null); then
        XMR_JSON="`curl -s ${MINER_NAME}:${httpd_port}/api.json`"
        HASH_RATE="`printf "$XMR_JSON" | \
            grep -Po '"total": ?\[\K[^,]+(?=,)'`"
        if [ "$HASH_RATE" = 'null' ]; then
            HASH_RATE='no data yet'
        fi
        POOL_ADDRESS="`printf "$XMR_JSON" | \
            grep -Po '"pool": ?"\K[^:]+(?=(:|"))'`"
        UP_SECS="`printf "$XMR_JSON" | \
            grep -Po '"uptime": ?\K[0-9]+(?=,)'`"
        UP_DAYS=$(( $UP_SECS / 86400 ))
        UP_SECS=$(( $UP_SECS % 86400 ))
        UP_HOURS=$(( $UP_SECS / 3600 ))
        UP_SECS=$(( $UP_SECS % 3600 ))
        UP_MINS=$(( $UP_SECS / 60 ))
        UP_SECS=$(( $UP_SECS % 60 ))
        UP_TEXT=''
        if [ $UP_DAYS -gt 0 ]; then
            UP_TEXT="${UP_DAYS}d "
        fi
        UP_TEXT+="`printf "%02d:%02d:%02d" \
            $UP_HOURS $UP_MINS $UP_SECS`"
        POOL_PING="`printf "$XMR_JSON" | \
            grep -Po '"ping": ?\K[0-9]+(?=,)'`"
        # print hash rate only:
        if [ "$FLAG_HASH" = 'true' ]; then
            printf ":: hash rate: $hashRate\n"
        # print full status:
        else
            printf ":: pool address: $POOL_ADDRESS\n"
            printf "           ping: $POOL_PING\n"
            printf "         uptime: $UP_TEXT\n"
            printf "      hash rate: $HASH_RATE\n"
        fi
    else
        printf ":: not mining\n"
    fi
    return 0
}

# Print wallet address.
print_wallet() {
    printf ":: wallet: "
    if [ `tput cols` -lt 107 ]; then
        printf "${wallet_address:0:48}\n"
        printf "           ${wallet_address:48}\n"
    else
        printf "${wallet_address}\n"
    fi
    if !(pgrep -x xmr-stak >/dev/null); then
        printf ":: not mining\n"
    fi
    return 0
}

# Copy existing config file or let script build one.
config_file() {
    if [ "$FLAG_CONFIG_FILE" = 'true' ]; then
        # use existing config:
        if [ -f "$XMR_CONFIG" ]; then
            cp "$XMR_CONFIG" ./config.txt
        # build new config:
        else
            printf ":! no config file found\n"
            printf ":: generating new config.txt\n"
            config_build
        fi
    # build new config:
    else
        config_build
    fi
    return 0
}

# Copy existing cpu config file or let xmr-stak build one.
cpu_file() {
    if [ -f "$XMR_CPU" ]; then
        cp "$XMR_CPU" ./cpu.txt
    else
        printf ":! no cpu file found\n"
        printf ":: generating new cpu.txt\n"
    fi
    return 0
}

# Copy existing nvidia config file or let xmr-stak build one.
nvidia_file() {
    if [ -f "$XMR_NVIDIA" ]; then
        cp "$XMR_NVIDIA" ./nvidia.txt
    else
        printf ":! no nvidia file found\n"
        printf ":: generating new nvidia.txt\n"
    fi
    return 0
}

# Build xmr-stak config.txt file.
config_build() {
    local XMR_CONFIG_TEXT=''
    # generate random pool weights:
    if [ "$FLAG_RANDOM_POOL" = 'true' ]; then
        pool_weights=( `shuf -i 1-${#pool_addresses[@]} \
            -n ${#pool_addresses[@]}` )
    fi
    # add default pool:
    if [ -n "$pool_address" ]; then
        pool_addresses+=( "$pool_address" )
        pool_weights+=( ${#pool_addresses[@]} )
        pool_passwords+=( "$pool_password" }
    fi
    # begin pool list:
    XMR_CONFIG_TEXT="\"pool_list\" :\n"
    XMR_CONFIG_TEXT+="[\n"
    i=0
    # add pools:
    for POOL in ${pool_addresses[@]}; do
        XMR_CONFIG_TEXT+="  {\n"
        XMR_CONFIG_TEXT+="    \"pool_address\" : \"$POOL\",\n"
        XMR_CONFIG_TEXT+="    \"wallet_address\" : \"$wallet_address\",\n"
        XMR_CONFIG_TEXT+="    \"pool_password\" : \"${pool_passwords[i]}\",\n"
        XMR_CONFIG_TEXT+="    \"pool_weight\" : ${pool_weights[i]},\n"
        XMR_CONFIG_TEXT+="    \"use_nicehash\" : $use_nicehash,\n"
        XMR_CONFIG_TEXT+="    \"use_tls\" : $use_tls,\n"
        XMR_CONFIG_TEXT+="    \"tls_fingerprint\" : \"$tls_fingerprint\"\n"
        XMR_CONFIG_TEXT+="  },\n"
        ((i++))
    done
    XMR_CONFIG_TEXT+="],\n"
    # add global settings:
    XMR_CONFIG_TEXT+="\"currency\" : \"$currency\",\n"
    XMR_CONFIG_TEXT+="\"call_timeout\" : $call_timeout,\n"
    XMR_CONFIG_TEXT+="\"retry_time\" : $retry_time,\n"
    XMR_CONFIG_TEXT+="\"giveup_limit\" : $giveup_limit,\n"
    XMR_CONFIG_TEXT+="\"verbose_level\" : $verbose_level,\n"
    XMR_CONFIG_TEXT+="\"print_motd\" : $print_motd,\n"
    XMR_CONFIG_TEXT+="\"h_print_time\" : $h_print_time,\n"
    XMR_CONFIG_TEXT+="\"aes_override\" : $aes_override,\n"
    XMR_CONFIG_TEXT+="\"use_slow_memory\" : \"$use_slow_memory\",\n"
    XMR_CONFIG_TEXT+="\"tls_secure_algo\" : $tls_secure_algo,\n"
    XMR_CONFIG_TEXT+="\"daemon_mode\" : $daemon_mode,\n"
    XMR_CONFIG_TEXT+="\"flush_stdout\" : $flush_stdout,\n"
    XMR_CONFIG_TEXT+="\"output_file\" : \"$output_file\",\n"
    XMR_CONFIG_TEXT+="\"httpd_port\" : $httpd_port,\n"
    XMR_CONFIG_TEXT+="\"http_login\" : \"$http_login\",\n"
    XMR_CONFIG_TEXT+="\"http_pass\" : \"$http_pass\",\n"
    XMR_CONFIG_TEXT+="\"prefer_ipv4\" : $prefer_ipv4,\n"
    printf "$XMR_CONFIG_TEXT" > config.txt
    return 0
}


##=============================  SCRIPT  =============================##
# parse args:
while [ -n "$1" ]; do case $1 in
#for arg in "$@"; do case $arg in
    --background|-B)   FLAG_DAEMON='true'                    ;;
    --config|-C)       FLAG_CONFIG_FILE='true'               ;;
    --cpu)             FLAG_CPU_FILE='true'                  ;;
    --dryrun|-D)       FLAG_DRYRUN='true'                    ;;
    --gen-config|-G)   FLAG_CONFIG_NEW='true'                ;;
    --hash|-H)         FLAG_HASH='true'                      ;;
    --help)            FLAG_HELP='true'                      ;;
    --kill|-K)         FLAG_KILL='true'                      ;;
    --nvidia|-N)       FLAG_NVIDIA_FILE='true'               ;;
    --pool|-p)         shift; pool_address="$1"              ;;
    --password|--pass) shift; pool_password="$1"             ;;
    --quiet|-Q|-I)     FLAG_QUIET='true'; FLAG_DAEMON='true' ;;
    --random-pool|-R)  FLAG_RANDOM_POOL='true'               ;;
    --show-hash|-H)    FLAG_HASH='true'                      ;;
    --show-status|-S)  FLAG_STATUS='true'                    ;;
    --show-wallet|-W)  FLAG_WALLET='true'                    ;;
    --wallet|-w)       shift; wallet_address="$1"            ;;
    # FAIL: unrecognized option:
    *)  printf ":! unrecognized option: $1\n"
        exit 5 ;;
esac; shift; done

# execute command line specified action:
mine_action

# precheck system before firing up miner:
mine_precheck

# switch to mining directory:
mkdir -p "$DIR_MINE"
cd "$DIR_MINE"

# use existing config or let script build new config.txt:
if [ "$FLAG_CONFIG_NEW" = 'false' ]; then
    config_file
else
    if [ -f config.txt ]; then
        rm config.txt
    fi
fi

# enable daemon_mode in config.txt:
if [ -f ./config.txt ] && [ "$FLAG_DAEMON" = 'true' ]; then
    sed -i 's/"daemon_mode" : false,/"daemon_mode" : true,/g;
        s/"verbose_level" : .*,/"verbose_level" : 0,/g;' config.txt
else
    FLAG_DAEMON='false'
fi

# copy default cpu config or let xmr-stak build new cpu.txt:
if [ "$FLAG_CPU_FILE" = 'true' ]; then
    cpu_file
fi

# copy default nvidia config or let xmr-stak build new nvidia.txt:
if [ "$FLAG_NVIDIA_FILE" = 'true' ]; then
    nvidia_file
fi

# launch xmr-stak:
if [ "$FLAG_DRYRUN" = 'false' ]; then
    # daemon mode:
    if [ "$FLAG_DAEMON" = 'true' ]; then
        # daemon incognito mode:
        if [ "$FLAG_INCOGNITO" = 'true' ]; then
            xmr-stak >/dev/null 2>&1 &
            sleep 2
        # daemon normal mode:
        else
            xmr-stak &
            sleep 2
            printf ":: xmr-stak forked to background PID: $!\n"
        fi
    # normal mode:
    else
        exec /usr/bin/xmr-stak
    fi
fi

exit 0
